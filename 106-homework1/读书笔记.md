作者是 1751650蒋伟博

问题描述。

我们想实现的一个函数是输入一个整数读入一个整数，输出一个。经过它翻转之后的整数，这个整数应该保持。嗯，对于负数应该同样有翻转的功能。

以下是一些示例。

| NO   | 输入  | 输出 |
| ---- | ----- | ---- |
| 1    | 5     | 5    |
| 2    | 0     | 0    |
| 3    | 123   | 321  |
| 4    | -3210 | -123 |

根据要求编写代码示，例如下代码如下。

```c#
using System;

public class ReverseInteger {
    public static void Main(String[] args) {
        int temp = 0;
        int flag = 1;
        int x = Convert.ToInt32(Console.ReadLine());

        if (x < 0) {
            flag = -1;
            x = -x;
        }

        while (x != 0) {
            temp *= 10;
            temp += x % 10;
            x /= 10;
        }

        Console.WriteLine(temp * flag);
    }
}
```

再根据代码，进行编译采用。I ld，sm进行分析。得到的。没人函数的反汇编结果如下。

```
.method public hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // 代码大小       76 (0x4c)
  .maxstack  3
  .locals init (int32 V_0,
           int32 V_1,
           int32 V_2,
           bool V_3)
  IL_0000:  nop
  IL_0001:  ldc.i4.0
  IL_0002:  stloc.0
  IL_0003:  ldc.i4.1
  IL_0004:  stloc.1
  IL_0005:  call       string [mscorlib]System.Console::ReadLine()
  IL_000a:  call       int32 [mscorlib]System.Convert::ToInt32(string)
  IL_000f:  stloc.2
  IL_0010:  ldloc.2
  IL_0011:  ldc.i4.0
  IL_0012:  clt
  IL_0014:  ldc.i4.0
  IL_0015:  ceq
  IL_0017:  stloc.3
  IL_0018:  ldloc.3
  IL_0019:  brtrue.s   IL_0022
  IL_001b:  nop
  IL_001c:  ldc.i4.m1
  IL_001d:  stloc.1
  IL_001e:  ldloc.2
  IL_001f:  neg
  IL_0020:  stloc.2
  IL_0021:  nop
  IL_0022:  br.s       IL_0037
  IL_0024:  nop
  IL_0025:  ldloc.0
  IL_0026:  ldc.i4.s   10
  IL_0028:  mul
  IL_0029:  stloc.0
  IL_002a:  ldloc.0
  IL_002b:  ldloc.2
  IL_002c:  ldc.i4.s   10
  IL_002e:  rem
  IL_002f:  add
  IL_0030:  stloc.0
  IL_0031:  ldloc.2
  IL_0032:  ldc.i4.s   10
  IL_0034:  div
  IL_0035:  stloc.2
  IL_0036:  nop
  IL_0037:  ldloc.2
  IL_0038:  ldc.i4.0
  IL_0039:  ceq
  IL_003b:  ldc.i4.0
  IL_003c:  ceq
  IL_003e:  stloc.3
  IL_003f:  ldloc.3
  IL_0040:  brtrue.s   IL_0024
  IL_0042:  ldloc.0
  IL_0043:  ldloc.1
  IL_0044:  mul
  IL_0045:  call       void [mscorlib]System.Console::WriteLine(int32)
  IL_004a:  nop
  IL_004b:  ret
} // end of method ReverseInteger::Main
```

代码分析。

首先我们来阅读一下文件头反汇编的反汇编函数的文件头。这些文件头并没有编录汇编指令，但也提供了相当重要的信息。
```
.method public hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // 代码大小       76 (0x4c)
  .maxstack  3
  .locals init (int32 V_0,
           int32 V_1,
           int32 V_2,
           bool V_3)
```
首先他告诉了我们代码大小是76。
其次，他告诉我们，Max du等于三，也就是。换句话说，也就是你原来Weixin stack的大小为三！
然后接下来是locals。嗯，local stint inlet里面告诉了我们。呃，在。在Costa里面总共有四个数值，分别是via微商。Reeling。其对应的。其对应的。饿几顿的属性分别是三个硬的32和一个ball。在接下来的分析中，我们会看到vb，二和v3分别对应。Amp，flag和x。

part 2 初始赋值。

该部分的功能是从嗯，对Tim跟flag。对两个变量赋予意境给定的初值，并且从Isle，并且从用户的输入io中读入一个我们需要处理的整数赋予x。c#的代码如下。

```c#
int temp = 0;
int flag = 1;
int x = Convert.ToInt32(Console.ReadLine());
```

其对应的。的反汇编代码如下。

```
  IL_0001:  ldc.i4.0
  IL_0002:  stloc.0
  IL_0003:  ldc.i4.1
  IL_0004:  stloc.1
  IL_0005:  call       string [mscorlib]System.Console::ReadLine()
  IL_000a:  call       int32 [mscorlib]System.Convert::ToInt32(string)
  IL_000f:  stloc.2
```

首先，ldc.i4指令将零和一依次放入evaluation stack中再调用。stloc指令将值分别放到call stack的零号和第一号位置上。

接下来从接下来，这两条命令分别调用了外部函数进行读入和数值的转换，最终得到了最终在Evaluation stack中。存在一个整数。在使用st lc指令把他存储到。Costa的第二号位置上。

part 3 判断正负。

```c#
if (x < 0) {
	flag = -1;
	x = -x;
}
```

对应的反汇编指令。

```
  IL_0010:  ldloc.2
  IL_0011:  ldc.i4.0
  IL_0012:  clt
  IL_0014:  ldc.i4.0
  IL_0015:  ceq
  IL_0017:  stloc.3
  IL_0018:  ldloc.3
  IL_0019:  brtrue.s   IL_0022
  IL_001b:  nop
  IL_001c:  ldc.i4.m1
  IL_001d:  stloc.1
  IL_001e:  ldloc.2
  IL_001f:  neg
  IL_0020:  stloc.2
  IL_0021:  nop
```

