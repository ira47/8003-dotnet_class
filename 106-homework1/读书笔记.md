## .net作业1——1751650蒋伟博

### 问题描述

我们想实现的一个函数是：读入一个整数，将其中的10进制数字逆序排列并输出。对于负数应该同样有翻转的功能。

以下是一些示例。

| NO   | 输入  | 输出 |
| ---- | ----- | ---- |
| 1    | 5     | 5    |
| 2    | 0     | 0    |
| 3    | 123   | 321  |
| 4    | -3210 | -123 |

### 代码

根据要求编写代码示，例如下代码如下。

```c#
using System;

public class ReverseInteger {
    public static void Main(String[] args) {
        int temp = 0;
        int flag = 1;
        int x = Convert.ToInt32(Console.ReadLine());

        if (x < 0) {
            flag = -1;
            x = -x;
        }

        while (x != 0) {
            temp *= 10;
            temp += x % 10;
            x /= 10;
        }

        Console.WriteLine(temp * flag);
    }
}
```

再对代码进行编译，采用ildasm进行反汇编分析。其中的Main函数汇编代码如下。

```
.method public hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // 代码大小       76 (0x4c)
  .maxstack  3
  .locals init (int32 V_0,
           int32 V_1,
           int32 V_2,
           bool V_3)
  IL_0000:  nop
  IL_0001:  ldc.i4.0
  IL_0002:  stloc.0
  IL_0003:  ldc.i4.1
  IL_0004:  stloc.1
  IL_0005:  call       string [mscorlib]System.Console::ReadLine()
  IL_000a:  call       int32 [mscorlib]System.Convert::ToInt32(string)
  IL_000f:  stloc.2
  IL_0010:  ldloc.2
  IL_0011:  ldc.i4.0
  IL_0012:  clt
  IL_0014:  ldc.i4.0
  IL_0015:  ceq
  IL_0017:  stloc.3
  IL_0018:  ldloc.3
  IL_0019:  brtrue.s   IL_0022
  IL_001b:  nop
  IL_001c:  ldc.i4.m1
  IL_001d:  stloc.1
  IL_001e:  ldloc.2
  IL_001f:  neg
  IL_0020:  stloc.2
  IL_0021:  nop
  IL_0022:  br.s       IL_0037
  IL_0024:  nop
  IL_0025:  ldloc.0
  IL_0026:  ldc.i4.s   10
  IL_0028:  mul
  IL_0029:  stloc.0
  IL_002a:  ldloc.0
  IL_002b:  ldloc.2
  IL_002c:  ldc.i4.s   10
  IL_002e:  rem
  IL_002f:  add
  IL_0030:  stloc.0
  IL_0031:  ldloc.2
  IL_0032:  ldc.i4.s   10
  IL_0034:  div
  IL_0035:  stloc.2
  IL_0036:  nop
  IL_0037:  ldloc.2
  IL_0038:  ldc.i4.0
  IL_0039:  ceq
  IL_003b:  ldc.i4.0
  IL_003c:  ceq
  IL_003e:  stloc.3
  IL_003f:  ldloc.3
  IL_0040:  brtrue.s   IL_0024
  IL_0042:  ldloc.0
  IL_0043:  ldloc.1
  IL_0044:  mul
  IL_0045:  call       void [mscorlib]System.Console::WriteLine(int32)
  IL_004a:  nop
  IL_004b:  ret
} // end of method ReverseInteger::Main
```

### 代码分析

#### part 1 文件头

首先我们来阅读一下文件头反汇编的反汇编函数的文件头。这些文件头并没有编录汇编指令，但也提供了相当重要的信息。
```
.method public hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // 代码大小       76 (0x4c)
  .maxstack  3
  .locals init (int32 V_0,
           int32 V_1,
           int32 V_2,
           bool V_3)
```
首先，他告诉了我们代码大小是76。

其次，他告诉我们，maxstack=3，也就是evaluation stack的大小为3。

最后，locals里的变量，对应call stack里的变量。它总共有四个值：v0, v1, v2, v3。变量的类型分别是三个int32和一个bool。在接下来的分析中，我们会看到v0, v1, v2分别对应temp, flag和x。

#### part 2 初始赋值

该部分的功能是对temp和flag两个变量赋予给定的初值。之后从用户的输入IO中，读入一个我们需要处理的整数，并将其赋予x。

c#的代码如下。

```c#
int temp = 0;
int flag = 1;
int x = Convert.ToInt32(Console.ReadLine());
```

其对应的反汇编代码如下。

```
  IL_0001:  ldc.i4.0
  IL_0002:  stloc.0
  IL_0003:  ldc.i4.1
  IL_0004:  stloc.1
  IL_0005:  call       string [mscorlib]System.Console::ReadLine()
  IL_000a:  call       int32 [mscorlib]System.Convert::ToInt32(string)
  IL_000f:  stloc.2
```

首先，ldc.i4指令将0和1依次放入evaluation stack中。再调用stloc指令，将值分别放到call stack的第0号和第1号位置上。

接下来05和0a这两条命令，分别调用了外部函数，进行读入和数值的转换，将读到的整数x放在在evaluation stack中。之后0f指令，用stloc指令把x存储到call stack的第2号位置上。

---



#### part 3 判断正负

```c#
if (x < 0) {
	flag = -1;
	x = -x;
}
```

对应的反汇编指令。

```
  IL_0010:  ldloc.2
  IL_0011:  ldc.i4.0
  IL_0012:  clt
  IL_0014:  ldc.i4.0
  IL_0015:  ceq
  IL_0017:  stloc.3
  IL_0018:  ldloc.3
  IL_0019:  brtrue.s   IL_0022
  IL_001b:  nop
  IL_001c:  ldc.i4.m1
  IL_001d:  stloc.1
  IL_001e:  ldloc.2
  IL_001f:  neg
  IL_0020:  stloc.2
  IL_0021:  nop
```

这里用到了三个比较/跳转的函数，分别是clt, ceq, brtrue.s。

1. clt: 比较两个值。如果第一个值小于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。
2. ceq: 比较两个值。如果这两个值相等，则将整数值 1 (int32) 推送到计算堆栈上；否则，将 0 (int32) 推送到计算堆栈上。
3. 如果 value 为 true、非空或非零，则将控制转移到目标指令（短格式）。

010到12指令比较了啊，计算x是否小于零，并将结果保存在Costa中一或者零。14和15的两个指令非常有意思。嗯，他比较了我们刚刚算出来的这个结果和我们刚刚算出来的表达式结果x小于零和零之间作比较。如果说他等于零，则结果为一，如果结果一则为零，相当于做了取反。为什么要这么做呢？看一九号指令。因为只有当，结果我一处的时候我们才需要跳转，换句话说，这里的执行逻辑跟我们在。逻辑不一样，si shop的语言逻辑是。当表达式值为真的时候a而在汇编语言中，逻辑是单结果为假的时候。结果真的时候对他敬 另起结果为假。使之不跳过。一个go to语句 嗯，执行本该执行的函数。

要si掉。二零几个语句是？If语句内部的语句。首先这里的me也就是这里的m，一是负一。要失踪的m一是负一，也就是将负一放入。Flag中。E.到二零语句对x进行取反。



